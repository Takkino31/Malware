import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, classification_report
import joblib
from flask import Flask, render_template, request, jsonify

app = Flask(__name__)

# Routes
@app.route('/')
def index():
    return render_template('index.html')

# Route pour prédire avec le modèle
@app.route('/predict', methods=['POST'])
def predict():
    # Charger les données à partir du fichier CSV
    chemin_fichier = "dataset.csv"
    dataset = pd.read_csv(chemin_fichier)

    # Séparation des features et des labels
    X = dataset.iloc[:, :-1]  # Features
    y = dataset.iloc[:, -1]    # Labels

    # Fractionner les données en ensembles d'entraînement et de test
    X_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.7, random_state=42)

    # Créer et entraîner les modèles
    models = {
        'Decision Tree': DecisionTreeClassifier(),
        'Random Forest': RandomForestClassifier(),
        'SVM': SVC(),
        'K-Nearest Neighbors': KNeighborsClassifier()
    }

    results = {}
    for name, model in models.items():
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        accuracy = accuracy_score(y_test, y_pred)
        report = classification_report(y_test, y_pred)
        results[name] = {'accuracy': accuracy, 'classification_report': report}

    # Trouver le modèle avec la meilleure exactitude
    best_model = max(results, key=lambda k: results[k]['accuracy'])

    # Sauvegarder le meilleur modèle
    joblib.dump(models[best_model], 'meilleur_modele.pkl')

    # Retourner les résultats au format JSON
    return jsonify({'results': results, 'best_model': best_model})

if __name__ == '__main__':
    app.run(debug=True)
